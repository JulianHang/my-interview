### 总结Java基础知识点

- `面向对象与面向过程的区别`：面向过程的性能要比面向对象好，因为面向对象在进行类调用时要实例化，注定要消耗资源，所以当性能是最重要的考量因素时，比如单片机、嵌入式开发、Linux一般采用面向过程开发。但是面向过程没有面向对象易扩展、易维护、易复用，因为面向对象具有封装、多态、继承特性，所以它可以设计出低耦合的系统，使系统更灵活。还有人认为Java性能差的原因是因为编译后的代码不能直接被CPU所执行，而面向过程语言大多都是直接编译成机器码直接执行。

- `Oracle JDK 与 Open JDK的对比`：Open JDK是一个参考模型并且是完全开源的，Oracle JDK是Open JDK的一个实现，并不是完全开源；Oracle JDK比Open JDK更稳定，两者的代码几乎相同，但Oracle JDK有更多的类和一些错误修复；在响应性和JVM性能方面，Oracle JDK提供更好的性能；Oracle JDK不会为即将发布的版本提供长期支持；Oracle JDK根据二进制代码许可协议获得许可，Open JDK根据GPL v2许可获得许可。

- `Java 与 C++的区别`：两者都是面向对象的语言，都支持封装，继承，多态；Java不提供指针来直接访问内存；Java中的类是单继承，而C++支持多继承，Java的接口支持多继承；Java有内存自动管理机制，不需要程序员手动释放无用内存；

- `封装`：把一个对象的属性私有化，然后提供访问这个属性的方法给外界调用。

- `继承`：可以在已存在的类的基础上建立新的类，新的类可以增加新的数据与功能，也可以使用父类的功能。

- `多态`：一个引用指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须由程序在运行期间才能决定。

- `StringBuilder 与 StringBuffer的区别`：StringBuffer对方法加锁了，所以是线程安全的，而StringBuilder是非线程安全的；因为加锁会消耗资源，所以StringBuilder的性能要比StringBuffer要好；

- `hashCode 与 equals的相关规定`：如果两个对象相等，则hashCode一定也相同；两个对象有相同的hashCode值，它们并不一定是相等的；

- `线程、程序、进程的概念与区别`：线程与进程类似，是比进程更小的执行单位。一个进程在执行的过程可以产生多个线程，这些线程共享同一片内存空间和一组系统资源，所以系统在各个线程间切换时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程；程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码；进程是程序的一次执行过程，是系统运行程序的基本单位，运行一个程序即是一个进程从创建、运行到消亡的过程。简单来说，一个进程就是一个执行中的程序。

- `有了字节流，为什么还要有字符流`：字符流是由Java虚拟机将字节转换得到的，这个过程还算比较耗时，并且如果我们不知道编码类型就很容易出现乱码问题，所以就干脆提供了一个直接操作字符的接口。

- `BIO/NIO/AIO的区别`：BIO是同步阻塞I/O模式，面向流，数据的读写必须阻塞在一个线程内等待完成，适合少量连接数的场景，通常情况会使用线程池来为每一个客户端连接分配一个线程，但这无疑会造成严重依赖线程，况且某些情况下会造成线程的浪费，比如没有读写，加上资源的有限很容易让性能达到瓶颈，所以出现了更高效的NIO；NIO同步非阻塞I/O模型，面向缓冲区，数据的读写不会造成阻塞，通过单线程轮询感兴趣的事件去处理不同的连接，即当某个连接没有可读数时能够处理其他的连接或读取，对于高并发来说，可以使用多线程来单独处理读写，即主线程收到连接后，通过事件分发器下发到指定的处理器上，由这些处理器进行处理，可以是不同的线程；AIO是异步非阻塞I/O模式，基于事件和回调机制实现的，也就是读写之后会直接返回，不会发生阻塞，当后台处理完成读写后，会通知相应的线程进行回调。

- `浮点数之间的等值判断`：基本数据类型不能用==来比较，包装数据类型不能用equals来判断，这跟浮点类型的计算方式有关，也就是说结果会导致精度丢失，所以一般情况下使用BigDecimal来定义浮点数的值。

- `JDK1.7HashMap在多线程下会发生死循环`：在发生扩容的情况因为多线程的影响链表节点会发生循环引用，从而导致死循环，也会造成数据丢失。

- `什么是死锁`： 多个线程同时阻塞，全部都在等待某个资源的释放。

- `如何避免死锁`：避免一个线程同时获取多个锁；尽量保证一个锁对应一个资源；尝试使用定时锁，即指定内没有获取到锁后就会退出。

- `类锁、对象锁`：这两种锁可以在同一个类中使用，互不影响。